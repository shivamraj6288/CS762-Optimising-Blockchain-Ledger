# from asyncio.windows_events import NULL
import copy

# from numpy.core.numeric import tensordot 
from block import Block, RegBlock
from transaction import Transaction
from event import *
# import heapq 
import numpy as np 
from random import sample
from utils import *
from block import Blockchain
from params import *
from queue import pushq

num_acc_bal_per_block=10
max_length_blockchain=100
mining_feee=50


class Node:
     

    def __init__(self, nid, speed, genesis, miningTime):
        self.nid = nid # unique id of all thr nodes 
        self.speed = speed # 1=fast, 0=slow
        self.blockchain = Blockchain(genesis)
        self.miningTime = miningTime # represent the mining power of node, mean mining time of node
        self.peer = set() # neighbours of the node
        self.txnReceived = set() # txn received till now 
        self.blockReceived = set() # blocks received till now 
        self.regenesis_status=False
        self.accounts=set()
        self.regBlockRecv=set()
        self.regenesisTime=[]
        self.waiting_to_merge =False 
        self.last_reg_block = None 
        


    def __str__ (self):
        return f"[Id:{pretty(self.nid, 5)}, Balance:{pretty(self.blockchain.balance(self.nid), 10)}]"

    # to establish connection between two node
    def addPeer(self,node):
        self.peer.add(node) 

    # this function is called if a new transaction is generated by the node 
    def txnSend(self, event):
        if self.blockchain.balance(self.nid) <= 0:
            return
        
        event.txn.value = np.random.randint(1, self.blockchain.balance(self.nid)+1)
        self.txnReceived.add(event.txn)

        for a in self.peer:
            t = event.time + computeLatency(self,a,1)
            action = TxnRecv(time=t, sender=self, receiver=a, txn=event.txn)
            pushq(action)

    # this function is called if the node recevies information about a transaction from its neighbours
    def txnRecv(self,event):
        if event.txn in self.txnReceived:
            return 
        self.txnReceived.add(event.txn)

        for a in self.peer:
            t = event.time + computeLatency(self,a,1)
            action = TxnRecv(time=t, sender=self.nid, receiver=a, txn=event.txn)
            pushq(action)

    # this function is called if node wants to mine a new block with given parent block
    def mineNewBlock(self, pblock, start_time):
        remaingTxn = self.txnReceived.difference(pblock.txnPool)
        txnToInclude = set(sample(remaingTxn, min(900,len(remaingTxn))))
        toBeDeleted = set()
        #print("debug p", pblock.balance)
        tmp_balance = pblock.balance.copy()
        for a in txnToInclude:
            if a.value > tmp_balance[a.sender.nid]:
                toBeDeleted.add(a)
            else:
                tmp_balance[a.sender.nid] -= a.value
                tmp_balance[a.receiver.nid] += a.value
        #print("debug", tmp_balance)
        txnToInclude = txnToInclude.difference(toBeDeleted)

        txnId = np.random.randint(0,2**31-1)
        coinBaseTxn = Transaction(tid=txnId, sender=-1, receiver=self, value=mining_feee)
        txnToInclude.add(coinBaseTxn)

        newBlockId = np.random.randint(0,2**31-1)
        newBlock = None
        if self.waiting_to_merge:
            newBlock = Block(bid=newBlockId, pbid=pblock, txnIncluded=txnToInclude, miner=self, regPbid=self.last_reg_block)
        else :
            newBlock = Block(bid=newBlockId, pbid=pblock, txnIncluded=txnToInclude, miner=self)
        assert newBlock.is_valid, "There is no point mining invalid blocks"
        mining_time = start_time + np.random.exponential(self.miningTime)
        newMiningEvent = BlockMined(time=mining_time, block=newBlock)
        pushq(newMiningEvent)
    
    def startMerging(self):
        self.waiting_to_merge = True 
        block = self.lastBlock
        bid = block.bid
        regBlock=None
        while (bid in self.blockchain.blocks.keys()):
            block = block.pbid 
            regBlock=block.regPbid
            self.blockchain.blocks.pop(bid)
            bid = block.bid 
        
        if regBlock!=None:
            block = regBlock
            bid = block.bid 
            while (bid in self.blockchain.blocks.keys()):
                block = block.pbid 
                self.blockchain.blocks.pop(bid)
                bid=block.bid 
        
            




    def mineRegBlock(self,block, start_time):
        remaining_accounts = self.accounts.difference(block.accIncluded)
        if len(remaining_accounts)==0:
            self.regenesis_status=False
            self.endRegTime=start_time
            self.regenesisTime.append(self.endRegTime-self.startRegTime)
            self.last_reg_block = block 
            self.startMerging()
              
            
            return 
        accounts_to_include=set(sample(remaining_accounts,min(num_acc_bal_per_block,len(self.accounts))))
        txns=set()
        for acc in accounts_to_include:
            txns.add(Transaction(tid=np.random.randint(0, 2**31-1),sender=0,receiver=acc[0],value=acc[1]))
        # self.accounts=self.accounts.difference(accounts_to_include)
        txnId = np.random.randint(0,2**31-1)
        coinBaseTxn = Transaction(tid=txnId, sender=-1, receiver=self, value=mining_feee)

        newBlockId = np.random.randint(0,2**31-1)
        newRegBlock= RegBlock(bid=newBlockId,pbid=block,txnIncluded=txns,miner=self,accIncluded=accounts_to_include)
        mining_time=start_time+np.random.exponential(self.miningTime)
        newRegMiningEvent = RegBlockMined(time=mining_time,block=newRegBlock)
        pushq(newRegMiningEvent)


    
    def startReGenesis(self,block,start_time):
        self.lastBlock = block 
        self.regenesis_status=True
        self.startRegTime=start_time
        # self.accounts=copy(block.balance)
        self.accounts=set(block.balance)
        accounts_to_include=set(sample(self.accounts,min(num_acc_bal_per_block,len(self.accounts))))
        txns=set()
        for acc in accounts_to_include:
            txns.add(Transaction(tid=np.random.randint(0, 2**31-1),sender=-1,receiver=acc[0],value=acc[1]))
        txnId = np.random.randint(0,2**31-1)
        coinBaseTxn = Transaction(tid=txnId, sender=-1, receiver=self, value=mining_feee)
        txns.add(coinBaseTxn)
        # self.accounts=self.accounts.difference(accounts_to_include)
        newBlockId = np.random.randint(0,2**31-1)
        newRegBlock= RegBlock(bid=newBlockId,pbid=block,txnIncluded=txns,miner=self,accIncluded=accounts_to_include, first=True)
        mining_time=start_time+np.random.exponential(self.miningTime)
        newRegMiningEvent = RegBlockMined(time=mining_time,block=newRegBlock)
        pushq(newRegMiningEvent)
        
        
    
    def receiveSelfMinedRegBlock(self,event):
        self.regBlockRecv.add(event.block.bid)
        is_long_reg = self.blockchain.add_reg_block(block=event.block, time=event.time)
        if is_long_reg: 
            for a in self.peer:
                lat = computeLatency(i=self, j=a, m=100+len(event.block.txnIncluded))
                action = RegBlockRecv(time=event.time+lat, sender=self, receiver=a, block=event.block)
                pushq(action)
            self.mineRegBlock(block=event.block,start_time=event.time)
            return True 
        
        return False 
    
    def verifyAndAddReceivedRegBlock(self,event):
        if event.block.bid in self.regBlockRecv:
            return 
        self.regBlockRecv.add(event.block.bid)
        if not event.block.is_valid: # we do not propogate invalid blocks
            return
        is_longest = self.blockchain.add_reg_block(event.block, event.time)
        if is_longest:
            self.mineRegBlock(block=event.block, start_time=event.time)

        for a in self.peer:
                lat = computeLatency(i=self, j=a, m=100+len(event.block.txnIncluded))
                action = RegBlockRecv(time=event.time+lat, sender=self, receiver=a, block=event.block)
                pushq(action)





        




    # this function is called, if node receives a block from its peers
    # block is verified and if the block is without any errors then its is added to blockchain 
    # and then transmitted to neighbours 
    # If addition of that block creates a primary chain then mining is started over that block
    def verifyAndAddReceivedBlock(self,event):
        if event.block.bid in self.blockReceived:
            return 
        self.blockReceived.add(event.block.bid)

        if not event.block.is_valid: # we do not propogate invalid blocks
            return
        
        is_longest = self.blockchain.add_block(event.block, event.time)

        

        if is_longest:
            if len(self.blockchain.blocks)==max_length_blockchain and self.regenesis_status==False:
                self.startReGenesis(block=event.block,start_time=event.time)
            if event.block.regPbid == self.last_reg_block:
                self.waiting_to_merge=False
                self.last_reg_block = None 
            self.mineNewBlock(pblock=event.block, start_time=event.time)
        
        for a in self.peer:
            lat = computeLatency(i=self,j=a,m=100+len(event.block.txnIncluded))
            action = BlockRecv(time=event.time + lat, sender=self, receiver=a, block=event.block)
            pushq(action)
    
    # this function is called once the mining of a block is completed, 
    # If after mining the addition of block creates a primary chain then
    # the block is shared with neighbours and mining is continued otherwise 
    # node waits a block whose addition will, create primary chain
    def receiveSelfMinedBlock(self, event):
        self.blockReceived.add(event.block.bid)
        is_longest = self.blockchain.add_block(event.block, event.time)

        if len(self.blockchain.blocks)==max_length_blockchain and self.regenesis_status==False:
            self.startReGenesis(block=event.block,start_time=event.time)

        rv = 0

        if is_longest:
            # print(f"{event.block}, Time:{pretty(event.time,10)}")
            if event.block.regPbid == self.last_reg_block:
                self.waiting_to_merge=False
                self.last_reg_block = None 
            rv = 1
            for a in self.peer:
                lat = computeLatency(i=self, j=a, m=100+len(event.block.txnIncluded))
                action = BlockRecv(time=event.time+lat, sender=self, receiver=a, block=event.block)
                pushq(action)
            self.mineNewBlock(pblock=event.block, start_time=event.time)
        
        return rv
    
